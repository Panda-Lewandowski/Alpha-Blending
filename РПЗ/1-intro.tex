\Introduction

 Оптимизация алгоритма - один из самых важных этапов разработки программного обеспечения. Он необходим практически при создании любого программного продукта. Модификации ПО, как правило, направлены на улучшение выходных характеристик алгоритмов при тех же технических требованиях. Напротив, изменения  продукта в визуальном плане составляют, пожалуй, наименьшую долю всех модификаций. Острую необходимость в оптимизации  требуют графические редакторы и игры. В них основные вычислительные затраты берут на себя сложные алгоритмы компьютерной графики. К примеру, серьезным недостатком метода трассировки лучей является производительность, так как для каждого пикселя необходимо заново производить процесс определения цвета, рассматривая каждый луч наблюдения в отдельности.
 
Можно выделить четыре вектора оптимизации алгоритма: 
\begin{enumerate}
\item улучшение временных характеристик. (уменьшение тактов процессора, требующихся для выполнения данной задачи). К примеру, минимизация операций деления и вычисления корня. 
\item качественных характеристик. Например, увеличение точности вычислений при дифференцировании с помощью формул Рунге, имеющих высокий порядок точности или достижение более качесвенного решения в задачах классификации  при использовании машинного обучения.
\item требуемых ресурсов. (уменьшение пространственной сложности алгоритма).
\item устойчивости алгоритма 
\end{enumerate}
 %(немножко про аппаратную часть тип сервера и тд )
 
 %Улучшение временных характеристик с прежним аппаратным обеспечением, и блаблабла
 
 
 %Если создаваемая программа будет использована только несколько раз, тогда стоимость написания и отладки программы будет доминировать в общей стоимости программы. В этом случае следует предпочесть алгоритм, наиболее простой для реализации.
 %Если программа будет работать только с «малыми» входными данными, то степень роста времени выполнения будет иметь меньшее значение, чем константа, присутствующая в формуле времени выполнения. Вместе с тем и понятие «малости» входных данных зависит от точного времени выполнения конкурирующих алгоритмов. Существуют алгоритмы, такие как алгоритм целочисленного умножения, асимптотически самые эффективные, но которые никогда не используют на практике даже для больших задач, так как их константы пропорциональности значительно превосходят подобные константы других, более простых и менее «эффективных» алгоритмов.
 %Эффективные, но сложные алгоритмы могут быть нежелательными, если готовые программы будут поддерживать лица, не участвующие в написании этих программ.
% Известно несколько примеров, когда эффективные алгоритмы требуют таких больших объемов машинной памяти (без возможности использования более медленных внешних средств хранения), что этот фактор сводит на нет преимущество «эффективности» алгоритма.
% В численных алгоритмах точность и устойчивость алгоритмов не менее важны, чем их временная эффективность.
 
 
 
 
