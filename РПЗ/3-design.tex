\chapter{ Констукторский раздел}
\label{cha:design}

Проведем оптимизацию смешения цветов в открытом графическом редакторе KDE Krita (https://krita.org/en/). 

\section{KoColorSpaceMaths}
Основная логика операций с цветами в Krita заложена в шаблонном классе KoColorSpaceMaths в одноименных файлах. 

\lstset{breaklines=true, numbers=left,
	keywordstyle=\color{blue}, commentstyle=\color{gray}}
\begin{lstlisting}[language=c++]
/* _T -- некоторый целочисленный тип c известной спецификацией 
* (миниальное/максимальное значение, начальное, нулевое значения, 
* эпсилон-значение, длина в битах), которая должна быть определена 
* в шаблонном классе KoColorSpaceMathsTraits через его явное определение.  
* _Tdst -- выходной тип, необходим,  если выходной тип не совпадает
*  с входным, иначе они равны */
template < typename _T, typename _Tdst = _T >
class KoColorSpaceMaths
{
    typedef KoColorSpaceMathsTraits<_T> traits;
    typedef typename traits::compositetype src_compositetype;
    typedef typename KoColorSpaceMathsTraits<_Tdst>::compositetype dst_compositetype;
public:
	// Перемножение двух чисел
    inline static _Tdst multiply(_T a, _Tdst b);
    // Перемножение трех чисел
    inline static _Tdst multiply(_T a, _Tdst b, _Tdst c);
    // Деление
    inline static dst_compositetype divide(_T a, _Tdst b);
    // Смешинваие двух цветов с нормаьной альфой
    inline static _T blend(_T a, _T b, _T alpha);
    // Преобразовывает а к типу _Tdst
    inline static _Tdst scaleToA(_T a);
    // 
    inline static dst_compositetype clamp(dst_compositetype val);
    inline static _Tdst clampAfterScale(dst_compositetype val);
};
\end{lstlisting}

На момент написания данной работы KoColorSpaceMaths имеет несколько спецализаций: double, float, half, quint8, quint16. Для работы с RGBA* используетя quint8. Рассмотрим специализацию KoColorSpaceMaths для этого типа.
\newpage
\lstset{breaklines=true, numbers=left,
	keywordstyle=\color{blue}, commentstyle=\color{gray}}
\begin{lstlisting}[language=c++]
//--------- quint8 specialization -----------//

template<>
inline quint8 KoColorSpaceMaths<quint8>::multiply(quint8 a, quint8 b)
{
    return (quint8)UINT8_MULT(a, b);
}


template<>
inline quint8 KoColorSpaceMaths<quint8>::multiply(quint8 a, quint8 b, quint8 c)
{
    return (quint8)UINT8_MULT3(a, b, c);
}

template<>
inline KoColorSpaceMathsTraits<quint8>::compositetype
KoColorSpaceMaths<quint8>::divide(quint8 a, quint8 b)
{
    return UINT8_DIVIDE(a, b);
}

template<>
inline quint8 KoColorSpaceMaths<quint8>::blend(quint8 a, quint8 b, quint8 c)
{
    return UINT8_BLEND(a, b, c);
}
\end{lstlisting}

Большинство функций реализовано через библиотеку KoIntegerMaths.
Чтобы обеспечить полноценную работу с цветами, необходимо оптимизировать каждую из этих функций.
Рассмотрим каждую функцию и способы ее оптимизации.

\newpage

\section{KoIntegerMaths}
%Dmitry Kazakov, [Nov 26, 2017, 6:58:13 PM]:
%Я бы начал с Баррета, а потом сказал бы, что мы просто добавляем округление к %операциям деления

%Плюс сравнил бы результат при умножении 0, 127, 128 и 255 между собой

%Эти результаты подсказали бы, что к Баррету нужно добавить округление

%До формулы 2.2 все норм, а потом должен начаться Баррет.
\subsection{UINT8\_MULT и UINT8\_MULT3}
\lstset{breaklines=true, numbers=left,
	keywordstyle=\color{blue}, commentstyle=\color{gray}}
\begin{lstlisting}[language=c++]
inline uint UINT8_MULT(uint a, uint b)
{
    uint c = a * b + 0x80u;
    return ((c >> 8) + c) >> 8;
}

inline uint UINT8_MULT3(uint a, uint b, uint c)
{
  uint t = a * b * c + 0x7F5B;
  return ((t >> 7) + t) >> 16;
}
\end{lstlisting}

Операция умножения компонент $RGB8$ и множество всех значений от 0 до 255 составляют собой некоммутативный моноид. В первую очередь, это означает, что $\forall a, b : a * b \in [0, 255]$, где знаком $*$ представлена операция умножения, то есть выполняется умножению по модулю 255. 

\begin{equation}
result = a * b~mod~255
\end{equation}


Следует заметить, что оптимизации деления на 255 не существует. Можно воспользоваться тем, что деление на 256 есть не что иное, как побитовый сдвиг вправо на 8. Однако стоит помнить, что должны использоваться целые числа, но
\begin{equation}
 \frac{255*255}{256} \approx 254.0039
\end{equation}

Далее должно произойти округление до 255, т.к. 255 есть нейтральный элемент в "моноиде RGB8".
Следовательно, необходимо использовать некое округление, причем можно найти случаи, когда округление ведется не в большую сторону, как в примере (2.2).

\begin{equation}
\frac{100*200}{256} \approx 78,125
\end{equation}
 
 Хотя 
 
 \begin{equation}
 \frac{100*200}{255} \approx 78,4314 \approx 78
 \end{equation}
 
 Здесь важна также одна небольшая деталь: при побитовом сдвиге число, над которым будет производиться данная операция, приводиться в типу \textit{integer} или производным от него, то есть дробная часть \textit{отбрасывается}. При округлении нам необходимо либо превысить исходное значение (тогда округление произойдет в большую сторону), либо не выходить за его пределы (тогда округление произойдет в меньшую сторону). 
 
 Добавим к умноженному значению число $t = \frac{256}{2}$, которое будет "приближать число" в сторону большего значения, и если число имело часть меньшую 0.5, то увеличение не произойдет.
 
Однако, в некоторых случаях умножение по модулю будет до сих пор происходить неверно: $(255*255+128) >> 8 = 254$. Добавим, еще одну "добавку". Только теперь она будет зависить от полученного результата и будет дополнять число до нужного.

Получим формулу из листинга: 
\begin{equation}
\begin{cases} 
c = (a * b + 128) >> 8 \\
result = ((c >> 8) + c) >> 8
\end{cases}
\end{equation}

Доказательство данных  предположений можно вывести благодаря работе Барретта, представившего в 1986 году  "Сокращение Барретта", алгоритма быстрого вычисления числа по модулю \cite{bib7}.

В  UINT8\_MULT3 используется похожая аппроксимация 
\begin{equation}
\frac{(a * b * c + 32512)}{65025.0}
\end{equation}

Данный алгоритм достаточно хорошо оптимизирован и не требует изменений. Несмотря на большее число проводимых операций, алгоритм тратит меньше тактов процессора, по сравнению с обычным делением по модулю.

\subsection{UINT8\_DIVIDE}
\begin{lstlisting}[language=c++]
inline uint UINT8_DIVIDE(uint a, uint b)
{
    uint c = (a * UINT8_MAX + (b / 2u)) / b;
    return c;
}
\end{lstlisting}

\subsection{UINT8\_BLEND}
