\chapter{ Технологический раздел}
\label{cha:design}

Проведем оптимизацию смешения цветов в открытом графическом редакторе KDE Krita (https://krita.org/). 


\section{Выбор вспомогательных библиотек}
Текущие компиляторы C++ могут выполнять автоматическое преобразование скалярных программ в инструкции SIMD (автовекторизация). Однако компилятор должен свойства алгоритма, который мог быть потерян, когда разработчик написал чисто скалярную реализацию в C++. Следовательно, компиляторы C++ не могут векторизовать какой-либо данный код в его наиболее эффективный параллельный вариант данных. Особенно большие параллельные данные, охватывающие несколько функцийи более, часто не будут преобразованы в эффективный код SIMD.

Бибилиотека Vc помгает справится с этой задачей. Ее типы позволяют явно указывать параллельные операции с данными по нескольким значениям. Поэтому параллелизм добавляется через систему типов. Конкурирующие подходы определяют параллелизм через новые структуры управления и, следовательно, новую семантику внутри тела этих структур управления.

Vc - это бесплатная библиотека программного обеспечения для упрощения явной векторизации кода на C++. Она имеет интуитивно понятный API и обеспечивает переносимость между различными компиляторами и версиями компилятора, а также переносимость между различными наборами векторных команд. 
\cite{bib8}


\section{Необходимые типы данных и классы}

\begin{table}[h!]
	\begin{center}
		\begin{tabular}{|c|c|}
			\hline
			Тип / Класс& Описание \\
			\hline
			\multicolumn{2}{|c|}{Библиотека Vc} \\
			\hline
			Vc::uint16\_v &  \\
		   Vc::Implementation &  \\
			Vc::SimdArray & uint32\_16\_v, int\_v\\
			\hline
			\multicolumn{2}{|c|}{Krita} \\
			\hline
			KoStreamedMath& \\
			OptimizedOverCompositor32 &  \\
			 KoDoubleOptimizedCompositeOpOver32 &  \\
			\hline
		\end{tabular}
	\end{center}
\end{table} 

\section{KoStreamMath}
Основная логика работы с цветами происходит в модуле KoStreamMath. Чтобы определить новый класс, который позволит нам внедрить оптимизированное смешение в проект, напишем несколько основных функций,чьими прототипами послужат неоптимизированные функции.

\subsection{fetch\_mask\_8\_uint16}
Функция получает на вход вектор, содержащий первые Vc::uint16\_v::size() значений маски и упаковывает их в вектор. Функция является статичной, встраиваемой в код (inline).

\begin{lstlisting}[language=c++]
static inline Vc::uint16_v fetch_mask_8_uint16(const quint8 *data) {
    Vc::uint16_v data_i(data);
    return data_i;
}
\end{lstlisting}

\subsection{fetch\_alpha\_uint16}
Шаблонная функция, распаковывает значения прозрачности в вектор в зависимости от выравнивания. Значение альфа храниться в наиболее значащем байте. Контролировать выравнивание необходимо по двум причнам:
\begin{enumerate}
\item Получение выровненных данных с невыровненной инструкцией ухудшает производительность.  
\item Получение невыровненных данных с выровненной инструкцией вызывает \#GP (исключение общей защиты).
\end{enumerate}

\begin{lstlisting}[language=c++]
template <bool aligned>
static inline uint16\_16\_v fetch\_alpha\_uint16(const quint8 *data) {
    uint32\_16\_v data\_i;
   if (aligned) {
       data\_i.load((const quint32*)data, Vc::Aligned);
   } else {
       data\_i.load((const quint32*)data, Vc::Unaligned);
   }

   return uint16\_16\_v(data\_i >> 24);
}
\end{lstlisting}

\subsection{fetch\_colors\_uint16}
Аналогично предыдущим функциям-распаковкам.

\begin{lstlisting}[language=c++]
template <bool aligned>
static inline void fetch\_colors\_uint16(const quint8 *data,
                            Vc::uint16\_v \&c1,
                            Vc::uint16\_v \&c2,
                            Vc::uint16\_v \&c3) {
    Vc::uint32\_v data\_i;
    if (aligned) {
        data\_i.load((const quint32*)data, Vc::Aligned);
    } else {
        data\_i.load((const quint32*)data, Vc::Unaligned);
    }

    const quint32 lowByteMask = 0xFF;
    Vc::uint32\_v mask(lowByteMask);

    c1 = Vc::uint16\_v((data\_i >> 16) \& mask);
    c2 = Vc::uint16\_v((data\_i >> 8)  \& mask);
    c3 = Vc::uint16\_v(data\_i         \& mask);
}
\end{lstlisting}

\subsection{write\_channels\_uint16}
Пакует цвет и альфа-значения в 4 канала по 8 бит на канал. Данные цвета хранятся в 3-х наименее значимых байтах пикселя, альфа - в наиболее значимом.

\begin{lstlisting}[language=c++]
static inline void write\_channels\_uint16(quint8 *data,
                                     Vc::uint16\_v::AsArg alpha,
                                     Vc::uint16\_v::AsArg c1,
                                     Vc::uint16\_v::AsArg c2,
                                     Vc::uint16\_v::AsArg c3) {
    const quint32 lowByteMask = 0xFF;

    uint32\_16\_v mask(lowByteMask);
    uint32\_16\_v v1 =   uint32\_16\_v(round(alpha)) << 24;
    uint32\_16\_v v2 = ( uint32\_16\_v(Vc::round(c1)) \& mask) << 16;
    uint32\_16\_v v3 = ( uint32\_16\_v(Vc::round(c2)) \& mask) <<  8;
    uint32\_16\_v v4 =  uint32\_16\_v(Vc::round(c3))  \& mask;
    v1 = v1 | v2;
    v3 = v3 | v4;
    (v1 | v3).store((quint32*)data, Vc::Aligned);
}
\end{lstlisting}

%Dmitry Kazakov, [Nov 26, 2017, 6:58:13 PM]:
%Я бы начал с Баррета, а потом сказал бы, что мы просто добавляем округление к %операциям деления

%Плюс сравнил бы результат при умножении 0, 127, 128 и 255 между собой

%Эти результаты подсказали бы, что к Баррету нужно добавить округление

%До формулы 2.2 все норм, а потом должен начаться Баррет.

\subsection{Умножение}

\begin{lstlisting}[language=c++]
static inline Vc::uint16\_v optimizedVectorMultiply(Vc::uint16\_v a, Vc::uint16\_v b)
{
static const Vc::uint16\_v offset(0x80u);
Vc::uint16\_v c = a * b + offset;
return ((c >> 8) + c) >> 8;
}
\end{lstlisting}

Операция умножения компонент $RGB8$ и множество всех значений от 0 до 255 составляют собой некоммутативный моноид. В первую очередь, это означает, что $\forall a, b : a * b \in [0, 255]$, где знаком $*$ представлена операция умножения, то есть выполняется умножению по модулю 255. 

\begin{equation}
result = a * b~mod~255
\end{equation}


Следует заметить, что оптимизации деления на 255 не существует. Можно воспользоваться тем, что деление на 256 есть не что иное, как побитовый сдвиг вправо на 8. Однако стоит помнить, что должны использоваться целые числа, но
\begin{equation}
\frac{255*255}{256} \approx 254.0039
\end{equation}

Далее должно произойти округление до 255, т.к. 255 есть нейтральный элемент в "моноиде RGB8".
Следовательно, необходимо использовать некое округление, причем можно найти случаи, когда округление ведется не в большую сторону, как в примере (2.2).

\begin{equation}
\frac{100*200}{256} \approx 78,125
\end{equation}

Хотя 

\begin{equation}
\frac{100*200}{255} \approx 78,4314 \approx 78
\end{equation}

Здесь важна также одна небольшая деталь: при побитовом сдвиге число, над которым будет производиться данная операция, приводиться в типу \textit{integer} или производным от него, то есть дробная часть \textit{отбрасывается}. При округлении нам необходимо либо превысить исходное значение (тогда округление произойдет в большую сторону), либо не выходить за его пределы (тогда округление произойдет в меньшую сторону). 

Добавим к умноженному значению число $t = \frac{256}{2}$, которое будет "приближать число" в сторону большего значения, и если число имело часть меньшую 0.5, то увеличение не произойдет.

Однако, в некоторых случаях умножение по модулю будет до сих пор происходить неверно: $(255*255+128) >> 8 = 254$. Добавим, еще одну "добавку". Только теперь она будет зависить от полученного результата и будет дополнять число до нужного.

Получим формулу из листинга: 
\begin{equation}
\begin{cases} 
c = (a * b + 128) >> 8 \\
result = ((c >> 8) + c) >> 8
\end{cases}
\end{equation}

Доказательство данных  предположений можно вывести благодаря работе Барретта, представившего в 1986 году  "Сокращение Барретта", алгоритма быстрого вычисления числа по модулю \cite{bib7}.


\subsection{Деление}
\begin{lstlisting}[language=c++]
static inline Vc::uint16\_v optimizedVectorDevide(Vc::uint16\_v a, Vc::uint16\_v b)
{
static const Vc::uint16\_v part(2u);
Vc::uint16\_v c = (a * UINT8\_MAX + (b / part)) / b;
return c;
}
\end{lstlisting}

\subsection{Смешение}
\begin{lstlisting}[language=c++]
static inline Vc::uint16\_v optimizedVectorBlend(Vc::uint16\_v a, Vc::uint16\_v b, Vc::uint16\_v alpha)
{
static const Vc::uint16\_v offset(0x80u);
Vc::uint16\_v c = (a - b) * alpha + offset;
c = ((c >> 8) + c) >> 8;
return c + b;
}

\end{lstlisting}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "rpz"
%%% End:
