\chapter{ Технологический раздел}
\label{cha:design}

Проведем оптимизацию смешения цветов в открытом графическом редакторе KDE Krita (https://krita.org/en/). 

\section{Необходимые типы данных}
Vc::uint16\_v
quint8

%using uint16_16_v = Vc::SimdArray<quint16, Vc::uint16_v::size()>;

\section{KoStreamMath}
Основная логика работы с цветами происходит в модуле KoStreamMath. Чтобы определить новый класс, который позволит нам внедрить оптимизированное смешение в проект, напишем несколько основных функций,чьими прототипами послужат неоптимизированные функции.

\subsection{fetch\_mask\_8\_uint16}
Функция получает на вход вектор, содержащий первые Vc::uint16\_v::size() значений маски и упаковывает их в вектор. Функция является статичной, встраиваемой в код (inline) и принадлежит структуре KoStreamedMath.
\lstset{breaklines=true, numbers=left,
	keywordstyle=\color{blue}, commentstyle=\color{gray}}
\begin{lstlisting}[language=c++]
static inline Vc::uint16_v fetch_mask_8_uint16(const quint8 *data) {
    Vc::uint16_v data_i(data);
    return data_i;
}
\end{lstlisting}

\subsection{fetch\_alpha\_uint16}
Шаблонная функция, распаковывает значения прозрачности в вектор в зависимости от выравнивания. Значение альфа храниться в наиболее значащем байте. Контролировать выравнивание необходимо по двум причнам:
\begin{enumerate}
\item Получение выровненных данных с невыровненной инструкцией ухудшает производительность.  
\item Получение невыровненных данных с выровненной инструкцией вызывает \#GP (исключение общей защиты).
\end{enumerate}
\lstset{breaklines=true, numbers=left,
	keywordstyle=\color{blue}, commentstyle=\color{gray}}
\begin{lstlisting}[language=c++]
template <bool aligned>
static inline uint16_16_v fetch_alpha_uint16(const quint8 *data) {
    uint32_16_v data_i;
   if (aligned) {
       data_i.load((const quint32*)data, Vc::Aligned);
   } else {
       data_i.load((const quint32*)data, Vc::Unaligned);
   }

   return uint16_16_v(data_i >> 24);
}
\end{lstlisting}

\subsection{fetch\_colors\_uint16}
Аналогично предыдущим функциям-распаковкам.
\lstset{breaklines=true, numbers=left,
	keywordstyle=\color{blue}, commentstyle=\color{gray}}
\begin{lstlisting}[language=c++]
template <bool aligned>
static inline void fetch_colors_uint16(const quint8 *data,
                            Vc::uint16_v &c1,
                            Vc::uint16_v &c2,
                            Vc::uint16_v &c3) {
    Vc::uint32_v data_i;
    if (aligned) {
        data_i.load((const quint32*)data, Vc::Aligned);
    } else {
        data_i.load((const quint32*)data, Vc::Unaligned);
    }

    const quint32 lowByteMask = 0xFF;
    Vc::uint32_v mask(lowByteMask);

    c1 = Vc::uint16_v((data_i >> 16) & mask);
    c2 = Vc::uint16_v((data_i >> 8)  & mask);
    c3 = Vc::uint16_v(data_i         & mask);
}
\end{lstlisting}

\subsection{write\_channels\_uint16}
Пакует цвет и альфа-значения в 4 канала по 8 бит на канал. Данные цвета хранятся в 3-х наименее значимых байтах пикселя, альфа - в наиболее значимом.
\lstset{breaklines=true, numbers=left,
	keywordstyle=\color{blue}, commentstyle=\color{gray}}
\begin{lstlisting}[language=c++]
static inline void write_channels_uint16(quint8 *data,
                                     Vc::uint16_v::AsArg alpha,
                                     Vc::uint16_v::AsArg c1,
                                     Vc::uint16_v::AsArg c2,
                                     Vc::uint16_v::AsArg c3) {
    const quint32 lowByteMask = 0xFF;

    uint32_16_v mask(lowByteMask);
    uint32_16_v v1 =   uint32_16_v(round(alpha)) << 24;
    uint32_16_v v2 = ( uint32_16_v(Vc::round(c1)) & mask) << 16;
    uint32_16_v v3 = ( uint32_16_v(Vc::round(c2)) & mask) <<  8;
    uint32_16_v v4 =  uint32_16_v(Vc::round(c3))  & mask;
    v1 = v1 | v2;
    v3 = v3 | v4;
    (v1 | v3).store((quint32*)data, Vc::Aligned);
}
\end{lstlisting}


\section{KoColorSpaceMaths}
Основная логика операций с цветами в Krita заложена в шаблонном классе KoColorSpaceMaths в одноименных файлах. 



На момент написания данной работы KoColorSpaceMaths имеет несколько спецализаций: double, float, half, quint8, quint16. Для работы с RGBA* используетя quint8. Рассмотрим специализацию KoColorSpaceMaths для этого типа.


Большинство функций реализовано через библиотеку KoIntegerMaths.
Чтобы обеспечить полноценную работу с цветами, необходимо оптимизировать каждую из этих функций.
Рассмотрим каждую функцию и способы ее оптимизации.


\section{KoIntegerMaths}
%Dmitry Kazakov, [Nov 26, 2017, 6:58:13 PM]:
%Я бы начал с Баррета, а потом сказал бы, что мы просто добавляем округление к %операциям деления

%Плюс сравнил бы результат при умножении 0, 127, 128 и 255 между собой

%Эти результаты подсказали бы, что к Баррету нужно добавить округление

%До формулы 2.2 все норм, а потом должен начаться Баррет.

static inline Vc::uint16_v optimizedVectorMultiply(Vc::uint16_v a, Vc::uint16_v b)
{
    static const Vc::uint16_v offset(0x80u);
    Vc::uint16_v c = a * b + offset;
    return ((c >> 8) + c) >> 8;
}

static inline Vc::uint16_v optimizedVectorDevide(Vc::uint16_v a, Vc::uint16_v b)
{
    static const Vc::uint16_v part(2u);
    Vc::uint16_v c = (a * UINT8_MAX + (b / part)) / b;
    return c;
}

static inline Vc::uint16_v optimizedVectorBlend(Vc::uint16_v a, Vc::uint16_v b, Vc::uint16_v alpha)
{
    static const Vc::uint16_v offset(0x80u);
    Vc::uint16_v c = (a - b) * alpha + offset;
    c = ((c >> 8) + c) >> 8;
    return c + b;
}
\subsection{UINT8\_MULT и UINT8\_MULT3}
\lstset{breaklines=true, numbers=left,
	keywordstyle=\color{blue}, commentstyle=\color{gray}}
\begin{lstlisting}[language=c++]
inline uint UINT8_MULT(uint a, uint b)
{
uint c = a * b + 0x80u;
return ((c >> 8) + c) >> 8;
}

inline uint UINT8_MULT3(uint a, uint b, uint c)
{
uint t = a * b * c + 0x7F5B;
return ((t >> 7) + t) >> 16;
}
\end{lstlisting}

Операция умножения компонент $RGB8$ и множество всех значений от 0 до 255 составляют собой некоммутативный моноид. В первую очередь, это означает, что $\forall a, b : a * b \in [0, 255]$, где знаком $*$ представлена операция умножения, то есть выполняется умножению по модулю 255. 

\begin{equation}
result = a * b~mod~255
\end{equation}


Следует заметить, что оптимизации деления на 255 не существует. Можно воспользоваться тем, что деление на 256 есть не что иное, как побитовый сдвиг вправо на 8. Однако стоит помнить, что должны использоваться целые числа, но
\begin{equation}
\frac{255*255}{256} \approx 254.0039
\end{equation}

Далее должно произойти округление до 255, т.к. 255 есть нейтральный элемент в "моноиде RGB8".
Следовательно, необходимо использовать некое округление, причем можно найти случаи, когда округление ведется не в большую сторону, как в примере (2.2).

\begin{equation}
\frac{100*200}{256} \approx 78,125
\end{equation}

Хотя 

\begin{equation}
\frac{100*200}{255} \approx 78,4314 \approx 78
\end{equation}

Здесь важна также одна небольшая деталь: при побитовом сдвиге число, над которым будет производиться данная операция, приводиться в типу \textit{integer} или производным от него, то есть дробная часть \textit{отбрасывается}. При округлении нам необходимо либо превысить исходное значение (тогда округление произойдет в большую сторону), либо не выходить за его пределы (тогда округление произойдет в меньшую сторону). 

Добавим к умноженному значению число $t = \frac{256}{2}$, которое будет "приближать число" в сторону большего значения, и если число имело часть меньшую 0.5, то увеличение не произойдет.

Однако, в некоторых случаях умножение по модулю будет до сих пор происходить неверно: $(255*255+128) >> 8 = 254$. Добавим, еще одну "добавку". Только теперь она будет зависить от полученного результата и будет дополнять число до нужного.

Получим формулу из листинга: 
\begin{equation}
\begin{cases} 
c = (a * b + 128) >> 8 \\
result = ((c >> 8) + c) >> 8
\end{cases}
\end{equation}

Доказательство данных  предположений можно вывести благодаря работе Барретта, представившего в 1986 году  "Сокращение Барретта", алгоритма быстрого вычисления числа по модулю \cite{bib7}.

В  UINT8\_MULT3 используется похожая аппроксимация 
\begin{equation}
\frac{(a * b * c + 32512)}{65025.0}
\end{equation}

Данный алгоритм достаточно хорошо оптимизирован и не требует изменений. Несмотря на большее число проводимых операций, алгоритм тратит меньше тактов процессора, по сравнению с обычным делением по модулю.

\subsection{UINT8\_DIVIDE}
\begin{lstlisting}[language=c++]
inline uint UINT8_DIVIDE(uint a, uint b)
{
uint c = (a * UINT8_MAX + (b / 2u)) / b;
return c;
}
\end{lstlisting}

\subsection{UINT8\_BLEND}


\section{Библиотека Vc}






%%% Local Variables:
%%% mode: latex
%%% TeX-master: "rpz"
%%% End:
